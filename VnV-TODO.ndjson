{"task":"Verify build_toy_ansatz produces correct tensor shape and values","priority":"High","source_file":"src/simulation/qft_backend.py","source_file_lines":"75:90","source_snippet":"def build_toy_ansatz(self, params): ...","python_snippet":"import numpy as np\nfrom simulation.qft_backend import PhysicsCore\nxs = np.linspace(-1,1,16)\ncore = PhysicsCore(grid=(xs, xs, xs), dx=xs[1]-xs[0])\nT = core.build_toy_ansatz({'alpha':2,'beta':1})\nassert T.shape == (4,4,16,16,16)\nr2 = sum(xi**2 for xi in np.meshgrid(xs,xs,xs,indexing='ij'))\nassert np.allclose(T[0,0], 2*np.exp(-r2))"}
{"task":"Test local_energy_density and find_negative for toy ansatz","priority":"Medium","source_file":"src/simulation/qft_backend.py","source_file_lines":"100:115","source_snippet":"def local_energy_density(self, T): ... def find_negative(self, rho): ...","python_snippet":"import numpy as np\nfrom simulation.qft_backend import PhysicsCore\nxs = np.linspace(-1,1,16)\ncore = PhysicsCore(grid=(xs, xs, xs), dx=xs[1]-xs[0])\nT = core.build_toy_ansatz({'alpha':1,'beta':1})\nrho = core.local_energy_density(T)\nmask = core.find_negative(rho)\nassert np.allclose(rho, T[0,0])\nassert not mask.any()"}
{"category":"V&V","task":"Integration test for HDF5 export of T_lqg tensor","priority":"High","source_file":"src/simulation/qft_backend.py","source_file_lines":"197-203","source_snippet":"with h5py.File('T_lqg.h5'","python_snippet":"import numpy as np\nimport h5py\nfrom simulation.qft_backend import PhysicsCore\nxs = np.linspace(-1,1,8)\ncore = PhysicsCore(grid=(xs,xs,xs), dx=xs[1]-xs[0])\nT = core.build_LQG_tensor({'alpha':1,'beta':1,'mass':0.1})\n# run main to export h5 file\nimport subprocess; subprocess.run(['python','-u','src/simulation/qft_backend.py'])\nwith h5py.File('T_lqg.h5','r') as hf:\n    data = hf['T_lqg'][:]\nassert data.shape == T.shape\nassert np.allclose(data, T)"}
{"category":"V&V","task":"Validate build_quantum_op_tensor returns correct tensor shape and type","priority":"Medium","source_file":"src/simulation/qft_backend.py","source_file_lines":"206-210","source_snippet":"def build_quantum_op_tensor","python_snippet":"import numpy as np\nfrom simulation.qft_backend import PhysicsCore\nxs = np.linspace(-1,1,8)\ncore = PhysicsCore(grid=(xs,xs,xs), dx=xs[1]-xs[0])\nT_q = core.build_quantum_op_tensor()\nassert hasattr(T_q, 'shape') and T_q.shape[:2] == (4,4)"}
{"category":"V&V","task":"Validate EnhancedStressEnergyComponents.verify_conservation returns boolean and error magnitude","priority":"Medium","source_file":"src/simulation/qft_backend.py","source_file_lines":"215-218","source_snippet":"esc.verify_conservation(xs)","python_snippet":"import numpy as np\nfrom simulation.qft_backend import PhysicsCore\nxs = np.linspace(-1,1,8)\ncore = PhysicsCore(grid=(xs, xs, xs), dx=xs[1]-xs[0])\nT_lqg = core.build_LQG_tensor({'alpha':1,'beta':1,'mass':0.1})\nesc = core.build_exotic_components(xs, T_lqg, T_lqg*0, T_lqg*0)\nvalid, error = esc.verify_conservation(xs)\nassert isinstance(valid, bool)\nassert isinstance(error, float)"}
{"category":"V&V","task":"Test detect_exotics outputs valid rho, mask, extra types","priority":"Medium","source_file":"src/simulation/qft_backend.py","source_file_lines":"207-210","source_snippet":"core.detect_exotics(T_q)","python_snippet":"import numpy as np\nfrom simulation.qft_backend import PhysicsCore\nxs = np.linspace(-1,1,8)\ncore = PhysicsCore(grid=(xs,xs,xs), dx=xs[1]-xs[0])\nT_q = core.build_quantum_op_tensor()\nrho, mask, extra = core.detect_exotics(T_q)\nassert rho.shape == mask.shape\nassert isinstance(extra, (dict, type(None)))"}
{"category":"V&V","task":"Integration test for evolve_QFT output length and content","priority":"Medium","source_file":"src/simulation/qft_backend.py","source_file_lines":"203-207","source_snippet":"phi_t = core.evolve_QFT","python_snippet":"import numpy as np\nfrom simulation.qft_backend import PhysicsCore\nxs = np.linspace(-1,1,8)\ncore = PhysicsCore(grid=(xs,xs,xs), dx=xs[1]-xs[0])\nphi0 = np.random.randn(8)\nphi_t = core.evolve_QFT(phi0, steps=10, dt=0.01)\nassert hasattr(phi_t, '__len__') and len(phi_t) == 10"}
{"task":"Validate evolve_QFT method handles 1D field input output","priority":"Low","source_file":"src/simulation/qft_backend.py","source_file_lines":"130:145","source_snippet":"def evolve_QFT(self, phi0, steps, dt): ...","python_snippet":"import numpy as np\nfrom simulation.qft_backend import PhysicsCore\nxs = np.linspace(-1,1,16)\ncore = PhysicsCore(grid=(xs, xs, xs), dx=xs[1]-xs[0])\nphi0 = np.zeros(16)\nphi_t = core.evolve_QFT(phi0, steps=10, dt=0.1)\nassert hasattr(phi_t, '__len__')"}
{"category":"V&V","task":"Validate pure T_{μν} injection routines","file":"src/simulation/parameter_sweep.py"}
{"category":"V&V","task":"Unit test discretization accuracy for Klein–Gordon operator","file":"src/simulation/lattice_qft.py"}
{"category":"V&V","task":"Integration test for result export to HDF5","file":"src/simulation/lattice_qft.py"}
{"category":"V&V","task":"Validate solve_semiclassical_metric returns correct history and final shapes","priority":"High","source_file":"src/simulation/backreaction.py","source_file_lines":"1-50","source_snippet":"def solve_semiclassical_metric","python_snippet":"import numpy as np; from simulation.backreaction import solve_semiclassical_metric; xs=np.linspace(0,1,10); h_final, history = solve_semiclassical_metric(xs, np.ones(10), dt=0.1, steps=5); assert history.shape==(6,10) and h_final.shape==(10,)"}
{"category":"V&V","task":"Validate spatial Laplacian integration in solve_semiclassical_metric","priority":"Medium","source_file":"src/simulation/backreaction.py","source_file_lines":"20-30","source_snippet":"laplacian = (np.roll(h, -1) - 2*h + np.roll(h, 1)) / (dx**2)","python_snippet":"# Input T00=0 and initial Gaussian h, verify propagation in history matches discrete wave equation"}
{"category":"V&V","task":"Validate discretization accuracy of 1+1D Klein–Gordon operator","priority":"High","source_file":"src/simulation/lattice_qft.py","source_snippet":"compute_energy_density and solve_klein_gordon","python_snippet":"# compare discrete Laplacian to analytical second derivative using sine wave initial condition"}
{"category":"V&V","task":"Integration test for HDF5 result export from parameter sweep demo","priority":"Medium","source_file":"scripts/lattice_sweep_demo.py","source_snippet":"with h5py.File('results/demo_sweep.h5','r')","python_snippet":"# run demo, open HDF5 file, verify dataset names and shapes"}
{"category":"V&V","task":"Unit test compute_casimir_plate_force returns expected force for known parameters","source_file":"src/simulation/mechanical_fem.py","source_file_lines":"98:120","source_snippet":"def compute_casimir_plate_force","python_snippet":"import numpy as np\nfrom simulation.mechanical_fem import compute_casimir_plate_force\n# Known case: perfect material, gap=1e-6 m, area=1e-12 m^2\ngap=1e-6; area=1e-12; hbar=1.054571817e-34; c=299792458\nexpected=(np.pi**2*hbar*c)/(240*gap**4)*area\nF=compute_casimir_plate_force(gap,area,'perfect')\nassert np.allclose(F, expected)"}
{"category":"V&V","task":"Integration test simulate_casimir_plate_deflection returns valid mechanical response dict","source_file":"src/simulation/mechanical_fem.py","source_file_lines":"120:142","source_snippet":"def simulate_casimir_plate_deflection","python_snippet":"from simulation.mechanical_fem import simulate_casimir_plate_deflection\nres=simulate_casimir_plate_deflection(gap=100e-9, plate_size=1e-6, thickness=100e-9, material='perfect')\nassert isinstance(res, dict)\nassert 'casimir_force' in res and 'max_deflection' in res and res['max_deflection'] >= 0"}