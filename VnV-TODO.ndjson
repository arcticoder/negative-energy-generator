{"task":"Verify build_toy_ansatz produces correct tensor shape and values","priority":"High","source_file":"src/simulation/qft_backend.py","source_file_lines":"75:90","source_snippet":"def build_toy_ansatz(self, params): ...","python_snippet":"import numpy as np\nfrom simulation.qft_backend import PhysicsCore\nxs = np.linspace(-1,1,16)\ncore = PhysicsCore(grid=(xs, xs, xs), dx=xs[1]-xs[0])\nT = core.build_toy_ansatz({'alpha':2,'beta':1})\nassert T.shape == (4,4,16,16,16)\nr2 = sum(xi**2 for xi in np.meshgrid(xs,xs,xs,indexing='ij'))\nassert np.allclose(T[0,0], 2*np.exp(-r2))"}
{"task":"Test local_energy_density and find_negative for toy ansatz","priority":"Medium","source_file":"src/simulation/qft_backend.py","source_file_lines":"100:115","source_snippet":"def local_energy_density(self, T): ... def find_negative(self, rho): ...","python_snippet":"import numpy as np\nfrom simulation.qft_backend import PhysicsCore\nxs = np.linspace(-1,1,16)\ncore = PhysicsCore(grid=(xs, xs, xs), dx=xs[1]-xs[0])\nT = core.build_toy_ansatz({'alpha':1,'beta':1})\nrho = core.local_energy_density(T)\nmask = core.find_negative(rho)\nassert np.allclose(rho, T[0,0])\nassert not mask.any()"}
{"task":"Validate evolve_QFT method handles 1D field input output","priority":"Low","source_file":"src/simulation/qft_backend.py","source_file_lines":"130:145","source_snippet":"def evolve_QFT(self, phi0, steps, dt): ...","python_snippet":"import numpy as np\nfrom simulation.qft_backend import PhysicsCore\nxs = np.linspace(-1,1,16)\ncore = PhysicsCore(grid=(xs, xs, xs), dx=xs[1]-xs[0])\nphi0 = np.zeros(16)\nphi_t = core.evolve_QFT(phi0, steps=10, dt=0.1)\nassert hasattr(phi_t, '__len__')"}
{"category":"V&V","task":"Validate pure T_{μν} injection routines","file":"src/simulation/parameter_sweep.py"}
{"category":"V&V","task":"Unit test discretization accuracy for Klein–Gordon operator","file":"src/simulation/lattice_qft.py"}
{"category":"V&V","task":"Integration test for result export to HDF5","file":"src/simulation/lattice_qft.py"}
{"category":"V&V","task":"Unit test compute_casimir_plate_force returns expected force for known parameters","source_file":"src/simulation/mechanical_fem.py","source_file_lines":"98:120","source_snippet":"def compute_casimir_plate_force","python_snippet":"import numpy as np\nfrom simulation.mechanical_fem import compute_casimir_plate_force\n# Known case: perfect material, gap=1e-6 m, area=1e-12 m^2\ngap=1e-6; area=1e-12; hbar=1.054571817e-34; c=299792458\nexpected=(np.pi**2*hbar*c)/(240*gap**4)*area\nF=compute_casimir_plate_force(gap,area,'perfect')\nassert np.allclose(F, expected)"}
{"category":"V&V","task":"Integration test simulate_casimir_plate_deflection returns valid mechanical response dict","source_file":"src/simulation/mechanical_fem.py","source_file_lines":"120:142","source_snippet":"def simulate_casimir_plate_deflection","python_snippet":"from simulation.mechanical_fem import simulate_casimir_plate_deflection\nres=simulate_casimir_plate_deflection(gap=100e-9, plate_size=1e-6, thickness=100e-9, material='perfect')\nassert isinstance(res, dict)\nassert 'casimir_force' in res and 'max_deflection' in res and res['max_deflection'] >= 0"}
